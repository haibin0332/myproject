% Quantizer Design
% Ref: A Perceptual Audio Hashing Algorithm: A Tool For Robust Audio Information Hiding
% 一个自适应的量化方法，可以加入随机化的过程
% 方法总的来说分为两步，第一步是构造一个量化器，第二步是量化
%{
原文的方法是：
    1、求所有输入数据的直方图分布
    2、按照等分布求得Levels等分，得到deta点
    3、得到每两个deta点之间的c点，等分布的中点
    4、在deta点左右随机得到A、B点，随机是分布的大小（即分布下面积占总面积的多少），A、B与deta的距离等分布
    5、按照某个规则随机控制A、B之间的量化结果。这个规则文章中猫腻了，没有说。
经过分析之后，决定改造成更加合理的实现方式，如下： 
    1、不求直方图分布，直接sort
    2、不按等分布求Levels，直接按照个数进行划分
    3、c点是没有价值的，不求
    4、A、B在deta点的两侧，按照规则随机选取，依据是等个数（等效于原方法的等分布）
    5、明确随机的量化方法是：或者A，或者B作为量化的基准，使用随机数来控制选择。A、B区间不能太大
%}
function binaryHash = adaptiveQuantizer(featureVector,bitlength,varargin)
%% test inputs
% featureVector = [-1.03898299008830,0.106576669029147,0.146816843316199,-0.970721619124158,1.11118010277331,-0.110050494567576,-0.358731586940546,0.0278970507549813,-0.643802294275866,2.04497174068956,-0.0530183259038697,1.09640102465199,-0.597428636948800,-0.459857923957860,-0.443491136018613,-0.199782889647734,-0.248126506977027,0.0776717766162220,0.257466925684989,0.120471722618071,0.641899602359807,0.707879657605947,-0.636960206667283,0.189286406788563,0.638961488244131,-0.286260425641181,0.287429327155097,-0.761305878448480,0.382323235386462,-0.721545416598566,-0.470021290326039,0.0265273007963881,-0.521128039052807,-0.0108408720890787,0.104374641359615,-0.101696100556047,-0.126802096258405,-0.224678372400110,-0.146904233341608,0.177216336251734,-0.289749239976902,0.396966879535469,-0.0382649673150766,0.0110768052801090,0.186718489721864,-0.168786205588822,-0.175747610745645,0.106808893197271,-0.0495109236906040,-0.0133930838240032,0.201124785743965,0.0667924242016469,0.260456504718903,0.164217376867708,0.181903943786578,-0.117699914202786,0.332175629981125,-0.443290968387269,-0.117680517883805,-0.351086960700388,-0.175750921888880,-0.0276312575255654,-0.269520697187936,-0.0124390344885533,-0.138825181343906,0.0215447183308151,0.247151049303663,-0.134205809972420,-0.208246541146571,0.0698852080435635,0.0954073552839298,-0.536529243961124,-0.409464700952021,-0.0125957138116725,0.114101936058508,0.112110522543388,0.0142578708972168,0.170169145657468,0.296780150012027,0.337741645132098,-0.000169464041550141,0.245326645076300,-0.196093393118055,-0.0310733404211762,0.185811195987014,0.291463687592067,-0.0354271696482746,-0.218191603973557,-0.0766385172443981,-0.116776807197900,-0.326733549827253,0.182589658701313,-0.0916883531593029,-0.146650634152369,-0.107849164833498;];
% bitlength = 2; % levels 为4的话表示量化之后需要两个bit来存储
% key = 101; 
%% function
% 一些调节参数
levelsNumber = 2^bitlength;
if ~isempty(varargin)
    key = varargin{1};  % 没有key就表示不要随机化，但还是自适应的
    if ~isnumeric(key)
        error('错误的输入');
    end
else
    key = 1;
end
if length(featureVector) < 8 * levelsNumber
    warning('特征点太少，或者级数太多');
    key = 1;
end    
% Sort
fv = sort(featureVector);
lfv = length(fv);
% 等分
qunit = round(lfv/levelsNumber);
levels = qunit*(1:levelsNumber - 1);
% levels的最后一个不需要记，大于levels(end - 1)的就是最后一级

if key ~= 1
    %% 需要随机化
    rand('seed',key);
    randomRadii = rand(1,levelsNumber - 1);
    % 调整一下，得到1-qunit/4之间的随机的整数
    randomRadii = floor(randomRadii * (floor(qunit/4) - 1) + 1); % 这里取1/4，相当于原文的参数，也可以取得更小
    % 对每一个deta点，左右取随机的相等的分布区间，这个分布区间必须要小于 1/2Q
    % 最后，量化的依据是在A B这两个点中的随机选取
    randomSelect = rand(1,levelsNumber - 1);
    randomSelect(randomSelect >= 0.5) = 1;
    randomSelect(randomSelect < 0.5) = -1;
    for i = 1:levelsNumber - 1
        levels(i) = levels(i) + randomSelect(i) * randomRadii(i);
    end        
end    
levels = fv(levels);
%% 使用levels量化出一堆等级
q = zeros(1,length(featureVector));
for i = 1:length(featureVector)
    for j = 1:length(levels) - 1
        if featureVector(i) <= levels(j + 1) && featureVector(i) > levels(j)
            q(i) = j;
        end
    end
    if featureVector(i) <= levels(1)
        q(i) = 0;
    end
    if featureVector(i) > levels(end)
        q(i) = length(levels);
    end
end    
%% 这种量化方式的量化结果用gray码编码比较合适
binaryHash = int2gray(q,bitlength);
